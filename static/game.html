<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LuluGo - å¯¹å¼ˆ</title>
    <script src="wgo.min.js"></script>
    <script src="socket.io.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: #2c3e50;
            color: white;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
        }
        #status { padding: 20px; font-size: 1.2em; font-weight: bold; }
        #board-container {
            width: 90vw;
            max-width: 600px;
            aspect-ratio: 1 / 1;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        .btn-group { display: flex; gap: 10px; margin: 20px; flex-wrap: wrap; justify-content: center;}
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            background: #3498db;
            color: white;
            cursor: pointer;
        }
        button:hover { background: #2980b9; }
        .btn-undo { background: #f39c12; }
        .btn-resign { background: #e74c3c; }
        .btn-ai { background: #8e44ad; }
        .btn-count { background: #16a085; }
        /* .btn-back { background: #95a5a6; } No longer used in bottom group */
        
        .btn-top-back {
            position: absolute;
            top: 15px;
            left: 15px;
            padding: 8px 15px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 0.9em;
            z-index: 100;
        }
        .btn-top-back:hover { background: rgba(255, 255, 255, 0.2); }
    </style>
</head>
<body>
    <button class="btn-top-back" onclick="back()">â¬… å¤§å…</button>

    <div id="game-info" style="display:flex; justify-content:space-around; width:100%; max-width:600px; padding:10px; background:#34495e; margin: 50px 0 10px 0; border-radius:8px;">
        <div id="black-player">âš« é»‘æ–¹: ???</div>
        <div id="turn-indicator" style="font-weight:bold; color:#f1c40f;">åŠ è½½ä¸­...</div>
        <div id="white-player">âšª ç™½æ–¹: ???</div>
    </div>
    
    <div id="board-container"></div>
    <div id="status" style="font-size:0.9em; color:#bdc3c7; height:20px;"></div>
    
    <div class="btn-group">
        <button class="btn-undo" onclick="undo()">æ‚”æ£‹</button>
        <button class="btn-resign" onclick="resign()">è®¤è¾“</button>
        <button class="btn-ai" onclick="estimateScore()">å½¢åŠ¿åˆ¤æ–­</button>
        <button class="btn-count" onclick="requestCount()">å¼€å§‹æ•°ç›®</button>
    </div>

    <script>
        const urlParams = new URLSearchParams(window.location.search);
        const gameId = parseInt(urlParams.get('id'));
        const userId = parseInt(sessionStorage.getItem('user_id'));

        const socket = io();
        let currentStones = [];
        let nextTurn = 'B';
        let lastMove = null;
        let myColor = null; // 'B' or 'W' or null (spectator)
        let ghostStone = null;
        let pendingCoord = null; // å¾…ç¡®è®¤çš„åæ ‡ {x, y, gtp}

        let isSubmitting = false;

        const board = new WGo.Board(document.getElementById('board-container'), {
            width: 600,
            size: 19,
            background: "#DCB35C"
        });

        // Register custom draw handler for Solid Square (Ownership)
        WGo.Board.drawHandlers.FILL_SQ = {
            draw: function(args, board) {
                var xr = board.getX(args.x),
                    yr = board.getY(args.y),
                    sr = board.stoneRadius * 0.8; // Slightly smaller than full stone
                
                var ctx = board.getContext();
                ctx.save();
                ctx.fillStyle = args.c || "rgba(0,0,0,0.5)";
                ctx.beginPath();
                ctx.rect(xr - sr, yr - sr, 2*sr, 2*sr);
                ctx.fill();
                ctx.restore();
            }
        };

        let showingEstimate = false;
        let estimateData = null;

        socket.on('connect', () => {
            socket.emit('auth', {user_id: userId});
            socket.emit('join_room', {game_id: gameId});
        });

        socket.on('board_update', (data) => {
            console.log("Board Update:", data);
            isSubmitting = false; // æœåŠ¡å™¨è¿”å›äº†ï¼Œè§£é™¤é”å®šï¼Œå¦‚æœä¹‹å‰æ˜¯ä¹è§‚æ›´æ–°ï¼Œç°åœ¨ä¼šè¢«æƒå¨çŠ¶æ€è¦†ç›–
            currentStones = data.moves;
            nextTurn = data.turn;
            lastMove = data.last_move;
            pendingCoord = null; // æ¯æ¬¡æ›´æ–°ç›˜é¢éƒ½é‡ç½®å¾…ç¡®è®¤çŠ¶æ€
            
            // ç¡®å®šæˆ‘çš„é¢œè‰² (ä»…å½“åŒ…å«èº«ä»½ä¿¡æ¯æ—¶å¤„ç†)
            if (data.is_player !== undefined) {
                if (data.is_player) {
                    if (data.black_id === userId) myColor = 'B';
                    else if (data.white_id === userId) myColor = 'W';
                } else {
                    myColor = null;
                }
            }

            // æ›´æ–°ç©å®¶ä¿¡æ¯
            if (data.black_name) document.getElementById('black-player').innerText = `âš« é»‘æ–¹: ${data.black_name}` + (myColor === 'B' ? " (ä½ )" : "");
            if (data.white_name) document.getElementById('white-player').innerText = `âšª ç™½æ–¹: ${data.white_name}` + (myColor === 'W' ? " (ä½ )" : "");
            
            // æ›´æ–°è½®æ¬¡æŒ‡ç¤º
            const turnText = nextTurn === 'B' ? 'é»‘æ£‹ä¸‹' : 'ç™½æ£‹ä¸‹';
            const ind = document.getElementById('turn-indicator');
            
            // çŠ¶æ€åŒæ­¥
            const statusDiv = document.getElementById('status');
            
            if (data.status === "WAITING") {
                ind.innerText = "ç­‰å¾…å¼€å§‹...";
                ind.style.backgroundColor = "#7f8c8d";
                ind.style.color = "white";
                statusDiv.innerText = "ç­‰å¾…å¯¹æ‰‹åŠ å…¥...";
            } else {
                ind.innerText = `Current: ${turnText}`;
                ind.style.backgroundColor = nextTurn === 'B' ? 'black' : 'white'; 
                ind.style.color = nextTurn === 'B' ? 'white' : 'black';
                statusDiv.innerText = `æ‰‹æ•°: ${currentStones.length} | ä¸Šä¸€æ­¥: ${lastMove || 'æ— '}`;
            }
            
            ind.style.padding = "2px 8px";
            ind.style.borderRadius = "4px";

            // æŒ‰é’®æ˜¾ç¤ºé€»è¾‘
            if (data.is_player !== undefined) {
                if (data.is_player === false) {
                    document.querySelector('.btn-group').style.display = 'none';
                    if(!statusDiv.innerText.includes("æ—è§‚")) {
                        statusDiv.innerText += " (æ—è§‚æ¨¡å¼)";
                    }
                } else {
                    document.querySelector('.btn-group').style.display = 'flex';
                }
            }

            renderBoard();
        });

        socket.on('game_start', (data) => {
             console.log("Game Start event received"); 
             // ä¸»è¦æ˜¯ board_update å¤„ç†äº†çŠ¶æ€ï¼Œè¿™é‡Œä¸éœ€è¦åšä»€ä¹ˆç‰¹æ®Šçš„ï¼Œ
             // æˆ–è€…å¯ä»¥åŠ ä¸€ä¸ªè§†è§‰æ•ˆæœ
        });

        socket.on('game_over', (data) => {
            let msg = `æ¸¸æˆç»“æŸï¼${data.result}`;
            if (data.result === 'B+Resign') msg = "æ¸¸æˆç»“æŸï¼é»‘æ£‹ä¸­ç›˜èƒœ (ç™½è®¤è¾“)";
            if (data.result === 'W+Resign') msg = "æ¸¸æˆç»“æŸï¼ç™½æ£‹ä¸­ç›˜èƒœ (é»‘è®¤è¾“)";

            alert(msg);
            
            // ç¦ç”¨æŒ‰é’®ï¼Œé”å®šæ£‹ç›˜ï¼ˆè™½ç„¶æœåŠ¡ç«¯å·²ç»ä¸æ¥å—moveäº†ï¼Œä½†å‰ç«¯ä¹Ÿå¯ä»¥å°ä½ï¼‰
            document.querySelector('.btn-undo').disabled = true;
            document.querySelector('.btn-resign').disabled = true;
            document.querySelector('.btn-group').innerHTML = 
                `<button class="btn-back" onclick="back()" style="flex:1; background:#8e44ad; font-weight:bold;">è¿”å›å¤§å…</button>`;
            
            // çŠ¶æ€æ æ›´æ–°
            document.getElementById('turn-indicator').innerText = "æ¸¸æˆå¯¹å±€ç»“æŸ";
            document.getElementById('status').innerText = msg;
        });

        socket.on('error', (data) => {
            if (isSubmitting) {
                 isSubmitting = false;
                 // å¦‚æœä¹‹å‰è¿›è¡Œäº†ä¹è§‚æ›´æ–°ï¼Œéœ€è¦æ’¤é”€
                 // ç®€å•åšæ³•ï¼šç§»é™¤ currentStones æœ€åä¸€ä¸ªå­ (æˆ‘ä»¬åˆšæ‰ push è¿›å»çš„)
                 // æ³¨æ„ï¼šåªæœ‰å½“æˆ‘ä»¬ç¡®è®¤æ˜¯è‡ªå·±åœ¨æäº¤æ—¶æ‰è¿™ä¹ˆåš
                 currentStones.pop(); 
                 renderBoard();
            }
            alert(data.msg);
        });

        function renderBoard() {
            try {
                // æ¸…é™¤æ‰€æœ‰å¯¹è±¡ï¼ˆåŒ…æ‹¬ä»¥å‰çš„ghost stonesï¼‰
                board.removeAllObjects();
                ghostStone = null; 
                // æ³¨æ„ï¼špendingCoord ä¸è¦åœ¨è¿™é‡Œæ¸…ç©ºï¼Œå› ä¸ºæˆ‘ä»¬å¯èƒ½åªæ˜¯é‡ç»˜

                // ç»˜åˆ¶å·²æœ‰æ£‹å­
                currentStones.forEach(stone => {
                    const [color, coord] = stone;
                    const pos = fromGTP(coord);
                    
                    let c = WGo.B;
                    if (color === 'W') c = WGo.W;
                    
                    board.addObject({x: pos.x, y: pos.y, c: c});
                    
                    // æ ‡è®°æœ€åä¸€æ­¥
                    if (coord === lastMove) {
                        board.addObject({
                            type: "CR",
                            x: pos.x, y: pos.y,
                            c: (color === 'B') ? "rgba(255,255,255,0.8)" : "rgba(0,0,0,0.8)"
                        });
                    }
                });

                // å¦‚æœæœ‰å¾…ç¡®è®¤çš„å­ï¼Œç»˜åˆ¶å‡ºæ¥ (è™šåŒ–çš„æ£‹å­/Outline)
                if (pendingCoord) {
                    const c = (myColor === 'B') ? WGo.B : WGo.W;
                    board.addObject({ 
                        x: pendingCoord.x, 
                        y: pendingCoord.y, 
                        c: c,
                        type: "outline"
                    });
                }

                // ç»˜åˆ¶å½¢åŠ¿åˆ¤æ–­ (Solid Squares)
                if (showingEstimate && estimateData && estimateData.ownership) {
                    for(let x=0; x<19; x++) {
                        for(let y=0; y<19; y++) {
                            const val = estimateData.ownership[x][y]; 
                            if (Math.abs(val) > 0.5) { 
                                // æ£€æŸ¥æ˜¯å¦å·²æœ‰æ£‹å­ -> å¦‚æœæœ‰æ£‹å­ï¼Œé€šå¸¸ ownership ä¹Ÿæ˜¯ç¡®å®šçš„ï¼Œ
                                // ç”¨æˆ·å¯èƒ½å¸Œæœ›çœ‹åˆ°å®åœ°è¦†ç›–åœ¨æ£‹å­ä¸Šï¼Ÿé€šå¸¸ Go server åªåœ¨ç©ºåœ°ä¸Šç”»ã€‚
                                // LuluGo ç°æœ‰é€»è¾‘æ˜¯ checks hasStone.
                                const gtp = toGTP(x, y);
                                const hasStone = currentStones.some(s => s[1] === gtp);
                                if (!hasStone) {
                                     board.addObject({
                                         type: "FILL_SQ",
                                         x: x, 
                                         y: y,
                                         c: val > 0 ? "rgba(0,0,0,0.7)" : "rgba(255,255,255,0.7)" 
                                     });
                                }
                            }
                        }
                    }
                }

            } catch (e) {
                console.error("Render Error:", e);
            }
        }

        // é¼ æ ‡ç§»åŠ¨ç›‘å¬ï¼šæ˜¾ç¤ºå·±æ–¹é¢œè‰²çš„è™šå½±
        board.addEventListener("mousemove", (x, y) => {
            // å¦‚æœä¸æ˜¯ç©å®¶ï¼Œæˆ–è€…æ¸¸æˆè¿˜æ²¡å¼€å§‹ï¼Œä¸æ˜¾ç¤º
            if (!myColor) return; 

            // æ£€æŸ¥è¾¹ç•Œ
            if (x < 0 || y < 0 || x >= 19 || y >= 19) return;

            // å¦‚æœè¯¥ä½ç½®å·²ç»æ˜¯å¾…ç¡®è®¤çš„ä½ç½®ï¼Œä¸éœ€è¦æ˜¾ç¤ºè™šå½±
            if (pendingCoord && pendingCoord.x === x && pendingCoord.y === y) {
                if(ghostStone) { board.removeObject(ghostStone); ghostStone=null; }
                return;
            }

            // æ£€æŸ¥è¯¥ä½ç½®æ˜¯å¦å·²æœ‰æ£‹å­
            const gtp = toGTP(x, y);
            const isOccupied = currentStones.some(s => s[1] === gtp);
            
            if (isOccupied) {
                if (ghostStone) {
                    board.removeObject(ghostStone);
                    ghostStone = null;
                }
                return;
            }

            // å¦‚æœå·²ç»æœ‰è™šå½±ä¸”ä½ç½®æ²¡å˜ï¼Œé€šè¿‡
            if (ghostStone && ghostStone.x === x && ghostStone.y === y) return;

            // ç§»é™¤æ—§è™šå½±
            if (ghostStone) {
                board.removeObject(ghostStone);
            }

            // æ·»åŠ æ–°è™šå½±ï¼šæ°¸è¿œæ˜¾ç¤ºè‡ªå·±çš„é¢œè‰² (myColor)
            ghostStone = {
                x: x, 
                y: y, 
                c: (myColor === 'B') ? WGo.B : WGo.W,
                type: "outline"
            };
            board.addObject(ghostStone);
        });

        // é¼ æ ‡ç§»å‡ºæ£‹ç›˜æ—¶æ¸…é™¤è™šå½±
        board.element.addEventListener("mouseleave", () => {
             if (ghostStone) {
                board.removeObject(ghostStone);
                ghostStone = null;
            }
        });

        // ç‚¹å‡»è½å­
        board.addEventListener("click", (x, y) => {
            // æ—è§‚è€…ä¸èƒ½è½å­
            if (!myColor) return;
            if (isSubmitting) return; // é˜²æ­¢é‡å¤æäº¤

            // æ ¸å¿ƒè¯·æ±‚ï¼šå¦‚æœä¸æ˜¯ä½ çš„å›åˆï¼Œæˆ–è€…æ¸¸æˆä¸åœ¨è¿›è¡Œä¸­ï¼Œç›´æ¥å¿½ç•¥
            const statusDiv = document.getElementById('status');
            // å¦‚æœ turn-indicator æ˜¾ç¤º waitï¼Œæˆ–è€… status æ˜¾ç¤º waitï¼Œåˆ™ä¸è®¸åŠ¨
            // ä¹Ÿå¯ä»¥ä¾èµ– game status å­—æ®µå¦‚æœèƒ½å…¨å±€æ‹¿åˆ°ï¼Œè¿™é‡Œå…ˆç”¨ UI çŠ¶æ€ç®€å•åˆ¤æ–­
            if (myColor !== nextTurn || (statusDiv && statusDiv.innerText.includes("ç­‰å¾…"))) {
                console.log("Not your turn or game waiting - click ignored");
                return;
            }

            if (x < 0 || y < 0 || x >= 19 || y >= 19) return;
            
            const gtp = toGTP(x, y);
             // æ£€æŸ¥æ˜¯å¦å ç”¨
            if (currentStones.some(s => s[1] === gtp)) return;

            // --- ç¡®è®¤è½å­æœºåˆ¶ ---
            
            // 1. å¦‚æœç‚¹å‡»çš„ä½ç½®å°±æ˜¯ pendingCoordï¼Œåˆ™æ˜¯ã€ç¡®è®¤è½å­ã€‘
            if (pendingCoord && pendingCoord.gtp === gtp) {
                console.log("Confirmed move:", gtp);
                
                // ä¹è§‚æ›´æ–° (Optimistic Update): ç«‹å³åœ¨æœ¬åœ°æ˜¾ç¤ºå®å¿ƒå­ï¼Œæ¶ˆé™¤å»¶è¿Ÿæ„Ÿ
                isSubmitting = true;
                currentStones.push([myColor, gtp]);
                lastMove = gtp;
                pendingCoord = null;
                renderBoard(); // ç«‹å³æ¸²æŸ“

                socket.emit('make_move', {game_id: gameId, coord: gtp});
                return; 
            }

            // 2. å¦‚æœç‚¹å‡»äº†å…¶ä»–ç©ºä½ï¼Œåˆ™æ›´æ–° pendingCoord å¹¶é‡ç»˜
            //    (ç¬¬ä¸€æ¬¡ç‚¹å‡»ï¼Œæˆ–è€…æ”¹å˜ä¸»æ„ç‚¹å‡»åˆ«å¤„)
            pendingCoord = {x, y, gtp};
            renderBoard(); // é‡ç»˜ä¼šæŠŠ old pending æ¸…æ‰ï¼Œç”»ä¸Š new pending
        });

        function undo() {
            socket.emit('undo_game', {game_id: gameId});
        }

        function resign() {
            if (confirm("ç¡®å®šè®¤è¾“å—ï¼Ÿ")) {
                socket.emit('resign_game', {game_id: gameId});
            }
        }

        function estimateScore() {
            // å¦‚æœå·²ç»æ˜¾ç¤ºï¼Œç‚¹å‡»åˆ™å…³é—­
            if (showingEstimate) {
                closeEstimate();
                return;
            }

            const statusDiv = document.getElementById('status');
            statusDiv.innerText = "â³ æ­£åœ¨AIå½¢åŠ¿åˆ¤æ–­...";
            
            socket.emit('estimate_score', {game_id: gameId}, (response) => {
                if (response) {
                    showingEstimate = true;
                    estimateData = response;
                    
                    // Add close button to status if not exists
                    statusDiv.innerHTML = `
                        <span style="color:#d35400; font-weight:bold;">å½¢åŠ¿åˆ¤æ–­: ${response.score}</span> 
                        <button onclick="closeEstimate()" style="padding:2px 8px; margin-left:10px; font-size:12px; vertical-align:middle; background:#7f8c8d;">å…³é—­æ˜¾ç¤º</button>
                    `;
                    
                    renderBoard(); // Will draw SQ because showingEstimate is true
                } else {
                    statusDiv.innerText = "å½¢åŠ¿åˆ¤æ–­å¤±è´¥";
                }
            });
        }

        function closeEstimate() {
            showingEstimate = false;
            estimateData = null;
            renderBoard();
            // Restore status text (approximate)
            const turnText = nextTurn === 'B' ? 'é»‘æ£‹ä¸‹' : 'ç™½æ£‹ä¸‹';
            document.getElementById('status').innerText = `æ‰‹æ•°: ${currentStones.length} | ä¸Šä¸€æ­¥: ${lastMove || 'æ— '}`;
        }

        function requestCount() {
            if (!confirm("ç”³è¯·å¼€å§‹æ•°ç›®ï¼Ÿ\nå¦‚æœå¯¹æ–¹åŒæ„ï¼ŒAI å°†åˆ¤å®šèƒœè´Ÿå¹¶ç»“æŸæ¸¸æˆã€‚")) return;
            console.log("Sending request_counting for game:", gameId);
            socket.emit('request_counting', {game_id: gameId});
            document.getElementById('status').innerText = "â³ å·²å‘é€æ•°ç›®è¯·æ±‚ï¼Œç­‰å¾…å¯¹æ–¹ç¡®è®¤...";
        }

        socket.on('counting_requested', () => {
             console.log("Received counting_requested event. MyColor:", myColor);
             
             // Update status for everyone in the room
             const statusDiv = document.getElementById('status');
             statusDiv.innerText = "ğŸ“£ å¯¹æ–¹è¯·æ±‚ç‚¹ç›®ï¼Œç­‰å¾…ç¡®è®¤...";
             statusDiv.style.color = "#e74c3c";
             statusDiv.style.fontWeight = "bold";

             // åªæœ‰å½“å‰ç©å®¶éœ€è¦å“åº”
             if (myColor) {
                 // Blink title to notify
                 const originalTitle = document.title;
                 let blink = setInterval(() => {
                     document.title = document.title === "ã€è¯·æ±‚ç‚¹ç›®ã€‘" ? "LuluGo - å¯¹å¼ˆ" : "ã€è¯·æ±‚ç‚¹ç›®ã€‘";
                 }, 1000);

                 setTimeout(() => {
                     clearInterval(blink);
                     document.title = originalTitle;
                     
                     if (confirm("ğŸ¤– å¯¹æ–¹ç”³è¯·å¼€å§‹æ•°ç›®å¹¶ç»“æŸæ¸¸æˆã€‚\n\næ‚¨åŒæ„ä½¿ç”¨AIåˆ¤å®šèƒœè´Ÿå—ï¼Ÿ")) {
                         socket.emit('accept_counting', {game_id: gameId});
                     } else {
                         // Optional: You could emit a 'reject_counting' event here and notify the other player
                         statusDiv.innerText = "å·²å¿½ç•¥ç‚¹ç›®è¯·æ±‚";
                         statusDiv.style.color = "#bdc3c7";
                     }
                 }, 200);
             }
        });

        function back() {
            window.location.href = '/static/lobby.html';
        }

        function toGTP(x, y) {
            const letters = "ABCDEFGHJKLMNOPQRST";
            return letters[x] + (19 - y);
        }

        function fromGTP(coord) {
            const letters = "ABCDEFGHJKLMNOPQRST";
            const col = letters.indexOf(coord[0].toUpperCase());
            const row = 19 - parseInt(coord.slice(1));
            return {x: col, y: row};
        }
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LuluGo - å¯¹å¼ˆ</title>
    <script src="wgo.min.js"></script>
    <script src="socket.io.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: #2c3e50;
            color: white;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
        }
        #status { padding: 20px; font-size: 1.2em; font-weight: bold; }
        #board-container {
            width: 90vw;
            max-width: 600px;
            aspect-ratio: 1 / 1;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        .btn-group { display: flex; gap: 10px; margin: 20px; flex-wrap: wrap; justify-content: center;}
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            background: #3498db;
            color: white;
            cursor: pointer;
        }
        button:hover { background: #2980b9; }
        .btn-undo { background: #f39c12; }
        .btn-resign { background: #e74c3c; }
        .btn-ai { background: #8e44ad; }
        .btn-count { background: #16a085; }
        /* .btn-back { background: #95a5a6; } No longer used in bottom group */
        
        .btn-top-back {
            position: absolute;
            top: 15px;
            left: 15px;
            padding: 8px 15px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 0.9em;
            z-index: 100;
        }
        .btn-top-back:hover { background: rgba(255, 255, 255, 0.2); }
        
        /* Modal Styles */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background: #2c3e50;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            border: 2px solid #f1c40f;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            max-width: 80%;
            color: white;
        }
    </style>
</head>
<body>
    <button class="btn-top-back" onclick="back()">â¬… å¤§å…</button>

    <!-- Modal for Counting Request -->
    <div id="counting-modal" class="modal-overlay">
        <div class="modal-content">
            <h3 style="margin-top:0;">ğŸ å¯¹æ–¹è¯·æ±‚ç‚¹ç›®</h3>
            <p>å¯¹æ–¹ç”³è¯·ç»“æŸæ¸¸æˆå¹¶è¿›è¡Œç‚¹ç›®ã€‚<br>æ˜¯å¦åŒæ„ï¼Ÿ</p>
            <div style="margin-top:20px; display:flex; gap:10px; justify-content:center;">
                <button onclick="confirmAcceptCounting()" style="background:#2ecc71;">åŒæ„</button>
                <button onclick="confirmRejectCounting()" style="background:#e74c3c;">æ‹’ç»</button>
            </div>
        </div>
    </div>

    <!-- Modal for Resign Confirmation -->
    <div id="resign-modal" class="modal-overlay">
        <div class="modal-content">
            <h3 style="margin-top:0; color:#e74c3c;">ğŸ³ï¸ è®¤è¾“ç¡®è®¤</h3>
            <p>ç¡®å®šè¦è®¤è¾“å—ï¼Ÿ<br>å¯¹å±€å°†ç«‹å³ç»“æŸã€‚</p>
            <div style="margin-top:20px; display:flex; gap:10px; justify-content:center;">
                <button onclick="confirmResign()" style="background:#e74c3c;">ç¡®è®¤è®¤è¾“</button>
                <button onclick="closeResignModal()" style="background:#7f8c8d;">å–æ¶ˆ</button>
            </div>
        </div>
    </div>
    <!-- Modal for Game Over -->
    <div id="game-over-modal" class="modal-overlay">
        <div class="modal-content">
            <h3 style="margin-top:0; color: #f1c40f;">ğŸ† æ¸¸æˆç»“æŸ</h3>
            <p id="game-over-reason" style="margin: 10px 0; color: #bdc3c7;"></p>
            <h2 id="game-over-result" style="margin: 20px 0; font-size: 2em; color: white;"></h2>
            <div style="margin-top:20px; display:flex; gap:10px; justify-content:center;">
                <button onclick="closeGameOverModal()" style="background:#3498db; flex: 1; padding: 12px; font-size: 1.1em;">æŸ¥çœ‹æ£‹å±€</button>
                <button onclick="back()" style="background:#8e44ad; flex: 1; padding: 12px; font-size: 1.1em;">è¿”å›å¤§å…</button>
            </div>
        </div>
    </div>

    <div id="game-info" style="display:flex; justify-content:space-around; width:100%; max-width:600px; padding:10px; background:#34495e; margin: 50px 0 10px 0; border-radius:8px;">
        <div id="black-player">âš« é»‘æ–¹: ???</div>
        <div id="turn-indicator" style="font-weight:bold; color:#f1c40f;">åŠ è½½ä¸­...</div>
        <div id="white-player">âšª ç™½æ–¹: ???</div>
    </div>
    
    <div id="board-container"></div>
    <div id="status" style="font-size:0.9em; color:#bdc3c7; height:20px;"></div>
    
    <div class="btn-group">
        <button class="btn-undo" onclick="undo()">æ‚”æ£‹</button>
        <button class="btn-resign" onclick="resign()">è®¤è¾“</button>
        <button class="btn-ai" onclick="estimateScore()">å½¢åŠ¿åˆ¤æ–­</button>
        <button class="btn-count" onclick="requestCount()">å¼€å§‹æ•°ç›®</button>
    </div>

    <script>
        const urlParams = new URLSearchParams(window.location.search);
        const gameId = parseInt(urlParams.get('id'));
        const userId = parseInt(sessionStorage.getItem('user_id'));

        const socket = io();
        let currentStones = [];
        let nextTurn = 'B';
        let lastMove = null;
        let myColor = null; // 'B' or 'W' or null (spectator)
        let ghostStone = null;
        let pendingCoord = null; // å¾…ç¡®è®¤çš„åæ ‡ {x, y, gtp}

        let isSubmitting = false;
        
        // --- Persistence Recovery ---
        let showingEstimate = false;
        let estimateData = null;
        
        // Check if we were estimating before refresh
        if (sessionStorage.getItem('isEstimating') === 'true' && 
            parseInt(sessionStorage.getItem('gameId')) === gameId) {
             try {
                estimateData = JSON.parse(sessionStorage.getItem('estimationData'));
                showingEstimate = true;
             } catch(e) {
                console.error("Failed to recover estimation data", e);
                sessionStorage.removeItem('isEstimating');
             }
        }

        const board = new WGo.Board(document.getElementById('board-container'), {
            width: 600,
            size: 19,
            background: "#DCB35C"
        });

        // Register custom draw handler for Solid Square (Ownership)
        // Use a unique type name 'M_SQ' (Mock/My Square) to avoid conflicts with WGo internals


        socket.on('connect', () => {
            socket.emit('auth', {user_id: userId});
            socket.emit('join_room', {game_id: gameId});
        });

        socket.on('board_update', (data) => {
            console.log("Board Update:", data);
            
            // å¦‚æœå¯¹æ–¹è½å­ï¼Œä¸”æˆ‘æ­£åœ¨çœ‹å½¢åŠ¿åˆ¤æ–­ -> å¼ºåˆ¶å…³é—­
            if (showingEstimate) {
                 console.log("Board updated, closing estimate.");
                 closeEstimate();
            }

            isSubmitting = false; // æœåŠ¡å™¨è¿”å›äº†ï¼Œè§£é™¤é”å®šï¼Œå¦‚æœä¹‹å‰æ˜¯ä¹è§‚æ›´æ–°ï¼Œç°åœ¨ä¼šè¢«æƒå¨çŠ¶æ€è¦†ç›–
            currentStones = data.moves;
            nextTurn = data.turn;
            lastMove = data.last_move;
            pendingCoord = null; // æ¯æ¬¡æ›´æ–°ç›˜é¢éƒ½é‡ç½®å¾…ç¡®è®¤çŠ¶æ€
            
            // ç¡®å®šæˆ‘çš„é¢œè‰² (ä»…å½“åŒ…å«èº«ä»½ä¿¡æ¯æ—¶å¤„ç†)
            if (data.is_player !== undefined) {
                if (data.is_player) {
                    if (data.black_id === userId) myColor = 'B';
                    else if (data.white_id === userId) myColor = 'W';
                } else {
                    myColor = null;
                }
            }

            // æ›´æ–°ç©å®¶ä¿¡æ¯
            if (data.black_name) document.getElementById('black-player').innerText = `âš« é»‘æ–¹: ${data.black_name}` + (myColor === 'B' ? " (ä½ )" : "");
            if (data.white_name) document.getElementById('white-player').innerText = `âšª ç™½æ–¹: ${data.white_name}` + (myColor === 'W' ? " (ä½ )" : "");
            
            // æ›´æ–°è½®æ¬¡æŒ‡ç¤º
            const turnText = nextTurn === 'B' ? 'é»‘æ£‹ä¸‹' : 'ç™½æ£‹ä¸‹';
            const ind = document.getElementById('turn-indicator');
            
            // çŠ¶æ€åŒæ­¥
            const statusDiv = document.getElementById('status');
            
            if (data.status === "WAITING") {
                ind.innerText = "ç­‰å¾…å¼€å§‹...";
                ind.style.backgroundColor = "transparent";
                ind.style.color = "white";
                statusDiv.innerText = "ç­‰å¾…å¯¹æ‰‹åŠ å…¥...";
            } else if (data.status === "ENDED") {
                 ind.innerText = "æ¸¸æˆå¯¹å±€ç»“æŸ";
                 ind.style.backgroundColor = "transparent";
                 ind.style.color = "white";
                 statusDiv.innerText = "å·²ç»“æŸ";
                 
                 // å¦‚æœæ¸¸æˆå·²ç»“æŸï¼Œç¡®ä¿åº•éƒ¨æŒ‰é’®æ˜¯â€œè¿”å›å¤§å…â€
                 showBackToLobbyButton();
            } else {
                ind.innerText = `Turn: ${turnText}`;
                
                // Consistent High Contrast Style
                if (nextTurn === 'B') {
                    ind.style.backgroundColor = "black";
                    ind.style.color = "white";
                    ind.style.border = "1px solid #444";
                    ind.style.textShadow = "none";
                } else {
                    ind.style.backgroundColor = "white";
                    ind.style.color = "black";
                    ind.style.border = "1px solid #ccc";
                    ind.style.textShadow = "none";
                }
                statusDiv.innerText = `æ‰‹æ•°: ${currentStones.length} | ä¸Šä¸€æ­¥: ${lastMove || 'æ— '}`;
            }
            
            ind.style.padding = "2px 8px";
            ind.style.borderRadius = "4px";

            // æŒ‰é’®æ˜¾ç¤ºé€»è¾‘
            if (data.is_player !== undefined) {
                if (data.is_player === false) {
                    document.querySelector('.btn-group').style.display = 'none';
                    if(!statusDiv.innerText.includes("æ—è§‚")) {
                        statusDiv.innerText += " (æ—è§‚æ¨¡å¼)";
                    }
                } else {
                    document.querySelector('.btn-group').style.display = 'flex';
                }
            }

            renderBoard();
        });

        socket.on('game_start', (data) => {
             console.log("Game Start event received"); 
             // ä¸»è¦æ˜¯ board_update å¤„ç†äº†çŠ¶æ€ï¼Œè¿™é‡Œä¸éœ€è¦åšä»€ä¹ˆç‰¹æ®Šçš„ï¼Œ
             // æˆ–è€…å¯ä»¥åŠ ä¸€ä¸ªè§†è§‰æ•ˆæœ
        });

        socket.on('game_over', (data) => {
            let resultText = data.result;
            
            // Format Result Text
            if (resultText === 'B+Resign') {
                resultText = "é»‘æ–¹ä¸­ç›˜èƒœ (ç™½è®¤è¾“)";
            } else if (resultText === 'W+Resign') {
                resultText = "ç™½æ–¹ä¸­ç›˜èƒœ (é»‘è®¤è¾“)";
            } else if (resultText && resultText.startsWith('B+')) {
                resultText = `é»‘èƒœ ${resultText.substring(2)} ç›®`;
            } else if (resultText && resultText.startsWith('W+')) {
                resultText = `ç™½èƒœ ${resultText.substring(2)} ç›®`;
            }
            
            // 1. Show Game Over Modal
            document.getElementById('game-over-reason').innerText = data.reason || "å¯¹å±€ç»“æŸ";
            document.getElementById('game-over-result').innerText = resultText;
            document.getElementById('game-over-modal').style.display = 'flex';

            // 2. Hide Counting Modal if open
            closeCountingModal();
            
            // 3. Update UI Controls (Disable game buttons, show Back button)
            showBackToLobbyButton();
            
            // 4. Update Status Bar
            document.getElementById('turn-indicator').innerText = "æ¸¸æˆå¯¹å±€ç»“æŸ";
            document.getElementById('status').innerText = `ç»“æœ: ${resultText}`;
        });

        function closeGameOverModal() {
            document.getElementById('game-over-modal').style.display = 'none';
        }

        function showBackToLobbyButton() {
            const btnGroup = document.querySelector('.btn-group');
            if (btnGroup) {
                // Clear existing buttons
                btnGroup.innerHTML = '';
                // Add Back button
                const backBtn = document.createElement('button');
                backBtn.className = 'btn-count'; 
                backBtn.innerText = 'è¿”å›å¤§å…';
                backBtn.onclick = back;
                backBtn.style.flex = '1';
                backBtn.style.background = '#8e44ad'; // Purple
                backBtn.style.fontWeight = 'bold';
                backBtn.style.fontSize = '16px';
                btnGroup.appendChild(backBtn);
                btnGroup.style.display = 'flex';
            }
        }

        socket.on('error', (data) => {
            if (isSubmitting) {
                 isSubmitting = false;
                 // å¦‚æœä¹‹å‰è¿›è¡Œäº†ä¹è§‚æ›´æ–°ï¼Œéœ€è¦æ’¤é”€
                 // ç®€å•åšæ³•ï¼šç§»é™¤ currentStones æœ€åä¸€ä¸ªå­ (æˆ‘ä»¬åˆšæ‰ push è¿›å»çš„)
                 // æ³¨æ„ï¼šåªæœ‰å½“æˆ‘ä»¬ç¡®è®¤æ˜¯è‡ªå·±åœ¨æäº¤æ—¶æ‰è¿™ä¹ˆåš
                 currentStones.pop(); 
                 renderBoard();
            }
            alert(data.msg);
        });

        function renderBoard() {
            try {
                // æ¸…é™¤æ‰€æœ‰å¯¹è±¡ï¼ˆåŒ…æ‹¬ä»¥å‰çš„ghost stonesï¼‰
                board.removeAllObjects();
                ghostStone = null; 
                // æ³¨æ„ï¼špendingCoord ä¸è¦åœ¨è¿™é‡Œæ¸…ç©ºï¼Œå› ä¸ºæˆ‘ä»¬å¯èƒ½åªæ˜¯é‡ç»˜

                // ç»˜åˆ¶å·²æœ‰æ£‹å­
                currentStones.forEach(stone => {
                    const [color, coord] = stone;
                    const pos = fromGTP(coord);
                    
                    let c = WGo.B;
                    if (color === 'W') c = WGo.W;
                    
                    board.addObject({x: pos.x, y: pos.y, c: c});
                    
                    // æ ‡è®°æœ€åä¸€æ­¥
                    if (coord === lastMove) {
                        board.addObject({
                            type: "CR",
                            x: pos.x, y: pos.y,
                            c: (color === 'B') ? "rgba(255,255,255,0.8)" : "rgba(0,0,0,0.8)"
                        });
                    }
                });

                // å¦‚æœæœ‰å¾…ç¡®è®¤çš„å­ï¼Œç»˜åˆ¶å‡ºæ¥ (è™šåŒ–çš„æ£‹å­/Outline)
                if (pendingCoord) {
                    const c = (myColor === 'B') ? WGo.B : WGo.W;
                    board.addObject({ 
                        x: pendingCoord.x, 
                        y: pendingCoord.y, 
                        c: c,
                        type: "outline"
                    });
                }

                // ç»˜åˆ¶å½¢åŠ¿åˆ¤æ–­ (Solid Squares)
                if (showingEstimate && estimateData && estimateData.ownership) {
                    // ç”±äº ownership çŸ©é˜µæ˜¯ row(y) col(x) è¿˜æ˜¯ col(x) row(y)?
                    // Python: ownership[row][col] -> ownership[y][x]
                    // é€šå¸¸ AI è¿”å›çš„æ˜¯ 19è¡Œï¼Œæ¯è¡Œ19åˆ—ã€‚
                    // æ‰€ä»¥ estimateData.ownership[0] æ˜¯ç¬¬ä¸€è¡Œ (y=19 in GTP, y=0 in WGo)
                    // WGo åæ ‡: (0,0) æ˜¯å·¦ä¸Šè§’ (A19)
                    
                    // é€æ˜åº¦è®¾ç½®ï¼š1.0 ä¸ºå®Œå…¨ä¸é€æ˜ï¼ˆå®å¿ƒï¼‰ï¼Œ0.0 ä¸ºå…¨é€æ˜ã€‚0.5 æ˜¯åŠé€æ˜ã€‚
                    const opacity = 0.9;
                    
                    for(let y=0; y<19; y++) {
                        for(let x=0; x<19; x++) {
                            const val = estimateData.ownership[y][x]; 
                            if (Math.abs(val) > 0.5) { 
                                // ç°åœ¨ä¸æ£€æŸ¥æ˜¯å¦æœ‰æ£‹å­ï¼Œç›´æ¥è¦†ç›–æ˜¾ç¤º
                                board.addObject({
                                    type: "SL",
                                    x: x, 
                                    y: y,
                                    c: val > 0 ? `rgba(0, 0, 0, ${opacity})` : `rgba(255, 255, 255, ${opacity})`
                                });
                            }
                        }
                    }
                }

            } catch (e) {
                console.error("Render Error:", e);
            }
        }

        // é¼ æ ‡ç§»åŠ¨ç›‘å¬ï¼šæ˜¾ç¤ºå·±æ–¹é¢œè‰²çš„è™šå½±
        board.addEventListener("mousemove", (x, y) => {
            // å¦‚æœä¸æ˜¯ç©å®¶ï¼Œæˆ–è€…æ¸¸æˆè¿˜æ²¡å¼€å§‹ï¼Œä¸æ˜¾ç¤º
            if (!myColor) return; 

            // æ£€æŸ¥è¾¹ç•Œ
            if (x < 0 || y < 0 || x >= 19 || y >= 19) return;

            // å¦‚æœè¯¥ä½ç½®å·²ç»æ˜¯å¾…ç¡®è®¤çš„ä½ç½®ï¼Œä¸éœ€è¦æ˜¾ç¤ºè™šå½±
            if (pendingCoord && pendingCoord.x === x && pendingCoord.y === y) {
                if(ghostStone) { board.removeObject(ghostStone); ghostStone=null; }
                return;
            }

            // æ£€æŸ¥è¯¥ä½ç½®æ˜¯å¦å·²æœ‰æ£‹å­
            const gtp = toGTP(x, y);
            const isOccupied = currentStones.some(s => s[1] === gtp);
            
            if (isOccupied) {
                if (ghostStone) {
                    board.removeObject(ghostStone);
                    ghostStone = null;
                }
                return;
            }

            // å¦‚æœå·²ç»æœ‰è™šå½±ä¸”ä½ç½®æ²¡å˜ï¼Œé€šè¿‡
            if (ghostStone && ghostStone.x === x && ghostStone.y === y) return;

            // ç§»é™¤æ—§è™šå½±
            if (ghostStone) {
                board.removeObject(ghostStone);
            }

            // æ·»åŠ æ–°è™šå½±ï¼šæ°¸è¿œæ˜¾ç¤ºè‡ªå·±çš„é¢œè‰² (myColor)
            ghostStone = {
                x: x, 
                y: y, 
                c: (myColor === 'B') ? WGo.B : WGo.W,
                type: "outline"
            };
            board.addObject(ghostStone);
        });

        // é¼ æ ‡ç§»å‡ºæ£‹ç›˜æ—¶æ¸…é™¤è™šå½±
        board.element.addEventListener("mouseleave", () => {
             if (ghostStone) {
                board.removeObject(ghostStone);
                ghostStone = null;
            }
        });

        // ç‚¹å‡»è½å­
        board.addEventListener("click", (x, y) => {
            // A. å½¢åŠ¿åˆ¤æ–­æ¨¡å¼ä¸‹ï¼š
            if (showingEstimate) {
                 // åªå“åº”å…³é—­æ“ä½œï¼Ÿä¸ï¼Œé€šå¸¸ç‚¹å‡»æ£‹ç›˜åº”è¯¥å…³é—­å½¢åŠ¿å¹¶å°è¯•è½å­ï¼Œæˆ–è€…ç›´æ¥ return
                 // æŒ‰ç…§éœ€æ±‚ï¼šåªæœ‰è‡ªå·±å…³é—­å½¢åŠ¿åˆ¤æ–­åæ‰èƒ½ç»§ç»­è¡Œæ£‹
                 alert("è¯·å…ˆå…³é—­å½¢åŠ¿åˆ¤æ–­ (ç‚¹å‡»æŒ‰é’®æˆ–ä¸Šæ–¹å…³é—­) å†è¿›è¡Œè½å­");
                 return;
            }

            // æ—è§‚è€…ä¸èƒ½è½å­
            if (!myColor) return;
            if (isSubmitting) return; // é˜²æ­¢é‡å¤æäº¤

            // æ ¸å¿ƒè¯·æ±‚ï¼šå¦‚æœä¸æ˜¯ä½ çš„å›åˆï¼Œæˆ–è€…æ¸¸æˆä¸åœ¨è¿›è¡Œä¸­ï¼Œç›´æ¥å¿½ç•¥
            const statusDiv = document.getElementById('status');
            // å¦‚æœ turn-indicator æ˜¾ç¤º waitï¼Œæˆ–è€… status æ˜¾ç¤º waitï¼Œåˆ™ä¸è®¸åŠ¨
            // ä¹Ÿå¯ä»¥ä¾èµ– game status å­—æ®µå¦‚æœèƒ½å…¨å±€æ‹¿åˆ°ï¼Œè¿™é‡Œå…ˆç”¨ UI çŠ¶æ€ç®€å•åˆ¤æ–­
            if (myColor !== nextTurn || (statusDiv && statusDiv.innerText.includes("ç­‰å¾…"))) {
                console.log("Not your turn or game waiting - click ignored");
                return;
            }

            if (x < 0 || y < 0 || x >= 19 || y >= 19) return;
            
            const gtp = toGTP(x, y);
             // æ£€æŸ¥æ˜¯å¦å ç”¨
            if (currentStones.some(s => s[1] === gtp)) return;

            // --- ç¡®è®¤è½å­æœºåˆ¶ ---
            
            // 1. å¦‚æœç‚¹å‡»çš„ä½ç½®å°±æ˜¯ pendingCoordï¼Œåˆ™æ˜¯ã€ç¡®è®¤è½å­ã€‘
            if (pendingCoord && pendingCoord.gtp === gtp) {
                console.log("Confirmed move:", gtp);
                
                // ä¹è§‚æ›´æ–° (Optimistic Update): ç«‹å³åœ¨æœ¬åœ°æ˜¾ç¤ºå®å¿ƒå­ï¼Œæ¶ˆé™¤å»¶è¿Ÿæ„Ÿ
                isSubmitting = true;
                currentStones.push([myColor, gtp]);
                lastMove = gtp;
                pendingCoord = null;
                renderBoard(); // ç«‹å³æ¸²æŸ“

                socket.emit('make_move', {game_id: gameId, coord: gtp});
                return; 
            }

            // 2. å¦‚æœç‚¹å‡»äº†å…¶ä»–ç©ºä½ï¼Œåˆ™æ›´æ–° pendingCoord å¹¶é‡ç»˜
            //    (ç¬¬ä¸€æ¬¡ç‚¹å‡»ï¼Œæˆ–è€…æ”¹å˜ä¸»æ„ç‚¹å‡»åˆ«å¤„)
            pendingCoord = {x, y, gtp};
            renderBoard(); // é‡ç»˜ä¼šæŠŠ old pending æ¸…æ‰ï¼Œç”»ä¸Š new pending
        });

        function undo() {
            socket.emit('undo_game', {game_id: gameId});
        }

        function resign() {
            // Show custom modal instead of confirm()
            document.getElementById('resign-modal').style.display = 'flex';
        }

        function confirmResign() {
            closeResignModal();
            socket.emit('resign_game', {game_id: gameId});
        }

        function closeResignModal() {
            document.getElementById('resign-modal').style.display = 'none';
        }

        function estimateScore() {
            // å¦‚æœå·²ç»æ˜¾ç¤ºï¼Œç‚¹å‡»åˆ™å…³é—­
            if (showingEstimate) {
                closeEstimate();
                return;
            }

            const statusDiv = document.getElementById('status');
            statusDiv.innerText = "â³ æ­£åœ¨AIå½¢åŠ¿åˆ¤æ–­...";
            
            socket.emit('estimate_score', {game_id: gameId}, (response) => {
                if (response) {
                    showingEstimate = true;
                    estimateData = response;
                    
                    // Local Storage Persistence
                    sessionStorage.setItem('estimationData', JSON.stringify(response));
                    sessionStorage.setItem('isEstimating', 'true');
                    sessionStorage.setItem('gameId', gameId);

                    // Add close button to status if not exists
                    // response æ˜¯ä» ai.py è¿”å›çš„ {rootInfo: {scoreLead...}, ownership...}
                    // å…ˆå¤„ç†æ•°æ®æ ¼å¼
                    let lead = 0;
                    if (response.rootInfo && response.rootInfo.scoreLead !== undefined) {
                         lead = response.rootInfo.scoreLead;
                    } else if (response.lead !== undefined) {
                         lead = response.lead; // Fallback
                    }
                    const leadText = (lead > 0 ? "é»‘+" : "ç™½+") + Math.abs(lead).toFixed(1);

                    statusDiv.innerHTML = `
                        <span style="color:#d35400; font-weight:bold;">å½¢åŠ¿åˆ¤æ–­: ${leadText}</span> 
                        <button onclick="closeEstimate()" style="padding:2px 8px; margin-left:10px; font-size:12px; vertical-align:middle; background:#7f8c8d;">å…³é—­æ˜¾ç¤º</button>
                    `;
                    
                    renderBoard(); // Will draw SQ because showingEstimate is true
                } else {
                    statusDiv.innerText = "å½¢åŠ¿åˆ¤æ–­å¤±è´¥";
                }
            });
        }

        function closeEstimate() {
            showingEstimate = false;
            estimateData = null;
            sessionStorage.removeItem('estimationData'); // Clear cache
            sessionStorage.removeItem('isEstimating');
            renderBoard();
            // Restore status text (approximate)
            updateStatus();
        }

        function requestCount() {
            if (!confirm("ç”³è¯·å¼€å§‹æ•°ç›®ï¼Ÿ\nå¦‚æœå¯¹æ–¹åŒæ„ï¼ŒAI å°†åˆ¤å®šèƒœè´Ÿå¹¶ç»“æŸæ¸¸æˆã€‚")) return;
            console.log("Sending request_counting for game:", gameId);
            socket.emit('request_counting', {game_id: gameId});
            document.getElementById('status').innerText = "â³ å·²å‘é€æ•°ç›®è¯·æ±‚ï¼Œç­‰å¾…å¯¹æ–¹ç¡®è®¤...";
        }

        socket.on('counting_requested', () => {
             console.log("Received counting_requested event. MyColor:", myColor);
             
             // Update status for everyone in the room
             const statusDiv = document.getElementById('status');
             statusDiv.innerText = "ğŸ“£ å¯¹æ–¹è¯·æ±‚ç‚¹ç›®ï¼Œç­‰å¾…ç¡®è®¤...";
             statusDiv.style.color = "#e74c3c";
             statusDiv.style.fontWeight = "bold";

             // åªæœ‰å½“å‰ç©å®¶éœ€è¦å“åº”
             if (myColor) {
                 // Blink title to notify
                 const originalTitle = document.title;
                 let blink = setInterval(() => {
                     document.title = document.title === "ã€è¯·æ±‚ç‚¹ç›®ã€‘" ? "LuluGo - å¯¹å¼ˆ" : "ã€è¯·æ±‚ç‚¹ç›®ã€‘";
                 }, 1000);
                 
                 // Show custom modal instead of system confirm
                 // This is non-blocking and more visible
                 const modal = document.getElementById('counting-modal');
                 modal.style.display = 'flex';
                 
                 // Store interval id to clear later
                 window.countingBlinkId = blink;
                 window.originalTitle = originalTitle;
             }
        });

        function confirmAcceptCounting() {
             closeCountingModal();
             socket.emit('accept_counting', {game_id: gameId});
        }

        function confirmRejectCounting() {
             closeCountingModal();
             // Optional: emit rejection
             const statusDiv = document.getElementById('status');
             statusDiv.innerText = "å·²æ‹’ç»ç‚¹ç›®è¯·æ±‚";
             statusDiv.style.color = "#bdc3c7";
             updateStatus(); // Restore normal status text
        }

        function closeCountingModal() {
             document.getElementById('counting-modal').style.display = 'none';
             if (window.countingBlinkId) {
                 clearInterval(window.countingBlinkId);
                 document.title = window.originalTitle;
                 window.countingBlinkId = null;
             }
        }

        function updateStatus() {
            const ind = document.getElementById('turn-indicator');
            const turnText = nextTurn === 'B' ? 'é»‘æ£‹ä¸‹' : 'ç™½æ£‹ä¸‹';
            ind.innerText = `Turn: ${turnText}` + (pendingCoord ? " (ç­‰å¾…ç¡®è®¤)" : "");
            
            // Re-apply correct color logic (Consistent High Contrast)
            if (nextTurn === 'B') {
                ind.style.backgroundColor = "black";
                ind.style.color = pendingCoord ? "#e74c3c" : "white";
                ind.style.border = "1px solid #444";
                ind.style.textShadow = "none";
            } else {
                ind.style.backgroundColor = "white";
                ind.style.color = pendingCoord ? "#e74c3c" : "black";
                ind.style.border = "1px solid #ccc";
                ind.style.textShadow = "none";
            }

            document.getElementById('status').innerText = `æ‰‹æ•°: ${currentStones.length} | ä¸Šä¸€æ­¥: ${lastMove || 'æ— '}`;
        }
        
        function back() {
            window.location.href = '/static/lobby.html';
        }

        function toGTP(x, y) {
            const letters = "ABCDEFGHJKLMNOPQRST";
            return letters[x] + (19 - y);
        }

        function fromGTP(coord) {
            const letters = "ABCDEFGHJKLMNOPQRST";
            const col = letters.indexOf(coord[0].toUpperCase());
            const row = 19 - parseInt(coord.slice(1));
            return {x: col, y: row};
        }
    </script>
</body>
</html>
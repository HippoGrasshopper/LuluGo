<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LuluGo - 复盘</title>
    <script src="wgo.min.js"></script>
    <script src="socket.io.min.js"></script>
    <script src="chart.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: #2c3e50;
            color: white;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
        }
        #status { padding: 10px; font-size: 1.2em; height: 30px;}
        #board-container {
            width: 90vw;
            max-width: 500px;
            aspect-ratio: 1 / 1;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        #winrate-container {
             width: 90vw;
             max-width: 500px;
             height: 100px;
             background: #34495e;
             margin: 10px 0;
             border-radius: 4px;
             position: relative;
        }
        .controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px;
            width: 90vw;
            max-width: 500px;
            justify-content: center;
        }
        button {
            padding: 10px 15px;
            border: none;
            border-radius: 6px;
            background: #3498db;
            color: white;
            cursor: pointer;
            font-size: 15px;
            white-space: nowrap; /* Prevent vertical text */
        }
        button:hover { background: #2980b9; }
        input[type="range"] {
            flex: 1;
        }
        
        .ai-controls {
            display: none;
            gap: 10px;
            background: #2c3e50;
            padding: 5px;
            border: 1px solid #8e44ad;
            border-radius: 8px;
        }
        .btn-ai { background: #8e44ad; }
        .btn-ai:hover { background: #9b59b6; }
        
        .btn-top-back {
            position: absolute;
            top: 15px;
            left: 15px;
            padding: 8px 15px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 0.9em;
            z-index: 100;
        }
    </style>
</head>
<body>
    <button class="btn-top-back" onclick="back()">⬅返回</button>

    <div id="game-info" style="display:flex; justify-content:space-around; align-items:center; width:100%; max-width:600px; padding:10px; background:#34495e; margin: 10px 0; border-radius:8px;">
        <div id="black-player" style="flex:1; text-align:center; font-size: 0.9em;">⚫ ???</div>
        <div id="status" style="width:150px; text-align:center; font-weight:bold; color:#f1c40f; margin:0 10px; font-size: 1.1em;">加载中</div>
        <div id="white-player" style="flex:1; text-align:center; font-size: 0.9em;">⚪ ???</div>
    </div>

    <div id="board-container"></div>
    
    <div id="winrate-container">
        <canvas id="winrate-chart"></canvas>
    </div>

    <!-- 标准控制栏 -->
    <div class="controls" id="normal-controls">
        <button onclick="jumpTo(0)" id="btn-start">⏮</button>
        <button onclick="step(-1)" id="btn-prev">◀</button>
        <input type="range" id="slider" min="0" max="0" value="0" oninput="jumpTo(this.value)" />
        <button onclick="step(1)" id="btn-next">▶</button>
        <button onclick="jumpTo(allMoves.length)" id="btn-end">⏭</button>
        
        <button id="btn-exit-trial" onclick="exitTrial()" style="display:none; background:#e67e22;">退出试下</button>
        <button id="btn-ai-recommend" onclick="toggleRecommendation()" style="background:#27ae60; margin-left:10px;">AI推荐</button>
        <button id="btn-exit-recommend" onclick="closeRecommendation()" style="display:none; background:#7f8c8d; margin-left:10px;">返回</button>
        <button id="btn-estimate" onclick="estimateScore()" style="background:#8e44ad; margin-left:10px;">形势判断</button>
    </div>

    <script>
        const urlParams = new URLSearchParams(window.location.search);
        const gameId = parseInt(urlParams.get('id'));

        // --- Socket & AI Vars ---
        const socket = io();
        let winrateChart = null;
        
        // --- Estimation Vars (Persistence) ---
        let showingEstimate = false;
        let estimateData = null;
         // Recover from session
        if (sessionStorage.getItem('isEstimating') === 'true' && 
            parseInt(sessionStorage.getItem('gameId')) === gameId) {
             try {
                estimateData = JSON.parse(sessionStorage.getItem('estimationData'));
                showingEstimate = true;
             } catch(e) {
                console.error("Failed to recover estimation data", e);
                sessionStorage.removeItem('isEstimating');
             }
        }
        let chartLinePlugin = {
             id: 'verticalLine',
             afterDraw: (chart) => {
                 if (chart.tooltip?._active?.length) return; 
                 const ctx = chart.ctx;
                 // Calculate X position based on current step
                 const step = isTrialMode ? (trialStartStep + currentTrialStep) : currentStep;
                 const x = chart.scales.x.getPixelForValue(step);
                 
                 ctx.save();
                 ctx.beginPath();
                 ctx.moveTo(x, chart.chartArea.top);
                 ctx.lineTo(x, chart.chartArea.bottom);
                 ctx.lineWidth = 2;
                 ctx.strokeStyle = '#e74c3c'; // Red cursor
                 ctx.stroke();
                 ctx.restore();
             }
        };

        // --- 数据结构 ---
        let allMoves = [];
        let currentStep = 0;
        let isTrialMode = false;
        let trialMoves = [];
        let trialStartStep = 0;
        let currentTrialStep = 0;

        // --- AI Recommendation State ---
        let isRecommendationMode = false;
        let isEvolutionMode = false;
        let recommendationData = null; // List of moveInfos
        let currentEvolutionPV = []; // List of moves

        // Define Custom Draw Handler for Solid Circle (AI Recommendation Stone) with Text
        // Must follow WGo internal structure: { stone: { draw: fn } }
        WGo.Board.drawHandlers.CRS = {
            stone: {
                draw: function(args, board) {
                    const xr = board.getX(args.x);
                    const yr = board.getY(args.y);
                    const sr = board.stoneRadius;
                    
                    // 1. Draw Circle
                    this.fillStyle = args.c || "rgba(0, 230, 118, 0.5)";
                    this.beginPath();
                    this.arc(xr, yr, sr, 0, 2 * Math.PI, true);
                    this.fill();
                    
                    // 2. Draw Text (Winrate) if provided
                    if (args.text) {
                        this.fillStyle = "black";
                        this.font = "bold " + (sr * 0.85) + "px sans-serif"; // Increased scaling
                        this.textAlign = "center";
                        this.textBaseline = "middle";
                        this.fillText(args.text, xr, yr);
                    }
                }
            }
        };

        const board = new WGo.Board(document.getElementById('board-container'), {
            width: 500,
            size: 19,
            background: "#DCB35C"
        });





        async function loadGame() {
            const res = await fetch(`/api/games/${gameId}`);
            const data = await res.json();
            allMoves = data.moves;
            
            // Set Player Names
            document.getElementById('black-player').innerText = "⚫ " + (data.black || "???");
            document.getElementById('white-player').innerText = "⚪ " + (data.white || "???");
            
            document.getElementById('slider').max = allMoves.length;
           
            if (restoreState()) {
                console.log("State restored");
            } else {
                currentStep = allMoves.length;
            }
             
            // Setup chart using real AI data if available
            setupChart(allMoves.length, data.ai_winrates || []);
            
            render();
        }

        // --- Winrate Chart ---
        function setupChart(totalMoves, aiWinrates) {
             if (typeof Chart === 'undefined') {
                 console.error("Chart.js failed to load");
                 document.getElementById('winrate-container').innerHTML = '<p style="text-align:center;line-height:100px;margin:0;color:#95a5a6">Winrate Chart Unavailable</p>';
                 return;
             }

             const ctx = document.getElementById('winrate-chart').getContext('2d');
             
             // Data Preparation
             // Move 0: 对于中国规则 7.5 目贴目，黑棋初始胜率通常在 42%-43% 左右 (KataGo 评估)
             // 为了避免图表开局就 50% 造成误解，如果没有实际 Move 0 分析数据，我们预设一个更科学的初始值，或者设为 null
             let dataPoints = [42.5]; 
             
             // Map backend (0.0 - 1.0) to chart (0 - 100)
             let hasRealData = false;
             if (aiWinrates && aiWinrates.length > 0) {
                 hasRealData = true;
                 const scaled = aiWinrates.map(w => parseFloat((w * 100).toFixed(1)));
                 
                 // 如果 AI 数据比棋谱少（正在分析中），则只显示已有的
                 dataPoints = dataPoints.concat(scaled);
             } else {
                 // No data available yet
                 // Don't fake it with 50s, show empty or label
                 dataPoints = [null]; // Start empty
             }
             
             // Ensure data length matches moves (handle partial analysis)
             // Fill remaining with null (gap)
             while (dataPoints.length < totalMoves + 1) {
                 dataPoints.push(null); 
             }
             
             const labels = Array.from({length: dataPoints.length}, (_, i) => i);
             
             // Update Status if analyzing
             if (!hasRealData && totalMoves > 0) {
                 const s = document.getElementById('status');
                 if(s && !s.innerText.includes("AI")) {
                      // Append quietly
                      // s.innerText += " (AI数据生成中...)"; 
                 }
             }

             winrateChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: '黑棋胜率',
                            data: dataPoints,
                            borderColor: '#2c3e50',
                            backgroundColor: 'rgba(0,0,0,0)',
                            borderWidth: 2,
                            pointRadius: (ctx) => {
                                const v = ctx.parsed.y;
                                return v === null ? 0 : 2;
                            },
                            tension: 0.1,
                            yAxisID: 'y',
                            spanGaps: false // Don't bridge huge gaps, let user see data is missing
                        },
                         {
                            label: '白棋胜率',
                            data: dataPoints.map(x => x === null ? null : (100 - x)),
                            borderColor: '#ecf0f1',
                            borderWidth: 1,
                            borderDash: [5, 5],
                            pointRadius: 0,
                            tension: 0.1,
                            yAxisID: 'y',
                            spanGaps: false
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: { mode: 'index', intersect: false },
                    plugins: { legend: { display: false } },
                    scales: {
                        y: { min: 0, max: 100, ticks: { callback: v => v+'%' }, grid: { color: '#555' } },
                        x: { grid: { display: false } }
                    },
                    onClick: (e) => {
                        const points = winrateChart.getElementsAtEventForMode(e, 'nearest', { intersect: false }, true);
                        if (points.length) {
                             jumpTo(points[0].index);
                             render();
                        }
                    }
                },
                plugins: [chartLinePlugin]
            });
        }

        // --- Render Core ---
        function render() {
            saveState();
            const game = new WGo.Game(19);
            
            // 1. Base Moves
            const realLimit = isTrialMode ? trialStartStep : currentStep;
            allMoves.slice(0, realLimit).forEach(m => playMoveGTP(game, m));

            // 2. Trial Moves
            if (isTrialMode) {
                trialMoves.slice(0, currentTrialStep).forEach(m => game.play(m.x, m.y, m.c));
            }

            // 3. Evolution Moves (Apply to game state so captures work)
            let evolutionCoords = [];
            // Apply evolution moves even if estimating score (so we see what we are estimating)
            if (isEvolutionMode && currentEvolutionPV) {
                currentEvolutionPV.forEach(gtp => {
                    const movePair = gtp.match(/([BWbw])?\[?([a-zA-Z]\d+)\]?/); // Try parse or just assume GTP string
                    // Actually our PV from mock is just coords like "Q16", "D4" or "PASS"
                    // But we need to know whose turn it is
                    const turn = game.turn; // WGo.B (1) or WGo.W (-1)
                    
                    if (gtp.toUpperCase() === 'PASS') {
                        game.pass(turn);
                        evolutionCoords.push(null);
                    } else {
                        const p = fromGTP(gtp);
                        // game.play automatically handles removing captured stones
                        const res = game.play(p.x, p.y, turn);
                        // Store coord for labeling
                        evolutionCoords.push({x: p.x, y: p.y, c: turn});
                    }
                });
            }

            // Draw Board (Stones)
            board.removeAllObjects();
            const position = game.getPosition();
            for (let x = 0; x < 19; x++) {
                for (let y = 0; y < 19; y++) {
                    const c = position.get(x, y); 
                    if (c) board.addObject({x, y, c});
                }
            }
            
            // Draw Last Move (Modified logic)
            // If Evolution Mode, last move is the last of PV
            let lastMoveObj = null;
            
            if (isEvolutionMode) {
                 // Last move of PV
                 // But wait, user might want to see the move BEFORE evolution as "marked"? 
                 // Usually for evolution, we label 1-10, so no single "last move" marker needed usually.
                 // So we skip CR marker for last move in Evolution mode.
            } else if (isTrialMode) {
                if (currentTrialStep > 0) {
                    const m = trialMoves[currentTrialStep - 1];
                    lastMoveObj = {x: m.x, y: m.y, c: m.c};
                } else if (trialStartStep > 0) {
                     const [lc, lcoord] = allMoves[trialStartStep - 1];
                     if (lcoord && lcoord.toUpperCase() !== 'PASS') {
                         const lp = fromGTP(lcoord);
                         lastMoveObj = {x: lp.x, y: lp.y, c: lc==='B'?WGo.B:WGo.W};
                     }
                }
            } else {
                if (currentStep > 0) {
                    const [lc, lcoord] = allMoves[currentStep - 1];
                    if (lcoord && lcoord.toUpperCase() !== 'PASS') {
                         const lp = fromGTP(lcoord);
                         lastMoveObj = {x: lp.x, y: lp.y, c: lc==='B'?WGo.B:WGo.W};
                    }
                }
            }

            // Draw Last Move Marker
            if (lastMoveObj && !showingEstimate && !isEvolutionMode) {
                board.addObject({
                    type: "CR",
                    x: lastMoveObj.x,
                    y: lastMoveObj.y,
                    c: lastMoveObj.c === WGo.B ? "white" : "black"
                });
            }
            
            // 4. Draw Recommendation (Green Squares)
            if (isRecommendationMode && !isEvolutionMode && recommendationData && !showingEstimate) {
                const top3 = recommendationData.slice(0, 3);
                
                top3.forEach(info => {
                    const p = fromGTP(info.move);
                    
                    // Revert to Winrate-based Alpha (as requested)
                    // The backend now provides larger winrate gaps for visual distinctness
                    let w = info.winrate;
                    if (game.turn === WGo.W) w = 1.0 - w; 
                    
                    const intensity = Math.max(0, Math.min(1, w));
                    // Base visibility 0.2 -> 0.25 for better aesthetics
                    const alpha = Math.max(0.25, intensity).toFixed(2);
                    
                    // Keep the Vibrant Material Green
                    const colorStr = `rgba(0, 230, 118, ${alpha})`;
                    
                    // Format winrate percentage (e.g. "56.2")
                    const winrateText = (w * 100).toFixed(1);

                    // Use new Custom Round Solid handler
                    board.addObject({
                        type: "CRS",
                        x: p.x,
                        y: p.y,
                        c: colorStr,
                        text: winrateText
                    });
                });
            }

            // 5. Draw Evolution Labels (Numbers)
            if (isEvolutionMode && evolutionCoords.length > 0 && !showingEstimate) {
                evolutionCoords.forEach((obj, index) => {
                     if (!obj) return; // PASS
                     // Draw Label (Number)
                     board.addObject({
                         type: "LB",
                         x: obj.x,
                         y: obj.y,
                         c: obj.c === WGo.B ? "white" : "black",
                         text: (index + 1).toString()
                     });
                });
            }

            // Draw Estimation (Solid Squares)
            if (showingEstimate && estimateData && estimateData.ownership) {

                const position = game.getPosition(); // Current board state
                
                // 透明度设置：1.0 为完全不透明（实心），0.0 为全透明
                const opacity = 0.9;
                
                // Use y then x convention for ownership matrix
                for(let y=0; y<19; y++) {
                    for(let x=0; x<19; x++) {
                        const val = estimateData.ownership[y][x]; 
                        if (Math.abs(val) > 0.2) { 
                             // Draw everywhere (dead stones will be covered)
                             board.addObject({
                                 type: "SL",
                                 x: x, 
                                 y: y,
                                 c: val > 0 ? `rgba(0,0,0,${opacity})` : `rgba(255,255,255,${opacity})` 
                             });
                        }
                    }
                }
            }

            updateUI(game);
            
             // Toggle Chart Visibility
            const chartContainer = document.getElementById('winrate-container');
            if (isTrialMode || isRecommendationMode || isEvolutionMode) {
                chartContainer.style.display = 'none';
            } else {
                chartContainer.style.display = 'block';
                if (winrateChart) winrateChart.update();
            }
        }

        function playMoveGTP(game, move) {
            const [color, coord] = move;
            if (coord.toUpperCase() === 'PASS') game.pass(color==='B' ? WGo.B : WGo.W);
            else {
                const pos = fromGTP(coord);
                game.play(pos.x, pos.y, color==='B' ? WGo.B : WGo.W);
            }
        }

        // --- UI Interactions ---
        function updateUI(game) {
            const statusDiv = document.getElementById('status');
            const slider = document.getElementById('slider');
            const exitBtn = document.getElementById('btn-exit-trial');
            const recommendBtn = document.getElementById('btn-ai-recommend');
            const exitRecBtn = document.getElementById('btn-exit-recommend');
            const estimateBtn = document.getElementById('btn-estimate');
            
            // 1. Status Text
            if (showingEstimate) {
                 statusDiv.innerText = "形势判断";
                 statusDiv.style.color = "#d35400";
            } else if (isRecommendationMode || isEvolutionMode) {
                 statusDiv.innerText = "AI 推荐";
                 statusDiv.style.color = "#2ecc71";
            } else if (isTrialMode) {
                 statusDiv.innerText = "试下中";
                 statusDiv.style.color = "#e67e22";
            } else {
                 statusDiv.innerText = `第 ${currentStep} 手`;
                 statusDiv.style.color = "#f1c40f";
            }
            
            // 2. Controls Visibility
            const isNormal = !isTrialMode && !isRecommendationMode && !isEvolutionMode;
            
            // Base visibility - Use display: none instead of visibility: hidden to remove space
            slider.style.display = (isNormal && !showingEstimate) ? 'block' : 'none';
            
            // Exit Trial Button: Only show if in Trial Mode AND NOT in AI modes
            // This prevents exiting trial while AI recommendation is still active on board
            if(exitBtn) {
                 exitBtn.style.display = (isTrialMode && !isRecommendationMode && !isEvolutionMode) ? 'inline-block' : 'none';
            }
            
            // AI Recommends Button Logic
            // Can be clicked in normal or trial, but hidden if already in recommendation/evolution
            if (isRecommendationMode || isEvolutionMode) {
                recommendBtn.style.display = 'none';
                exitRecBtn.style.display = (showingEstimate) ? 'none' : 'inline-block'; // Hide back button if estimating
            } else {
                recommendBtn.style.display = (showingEstimate) ? 'none' : 'inline-block'; // Hide recommend button if estimating
                exitRecBtn.style.display = 'none';
            }
            
            // Update Estimate Button Text
            if (estimateBtn) {
                if (showingEstimate) {
                    estimateBtn.innerText = "关闭形势判断";
                    estimateBtn.style.background = "#7f8c8d"; // Grey
                } else {
                    estimateBtn.innerText = "形势判断";
                    estimateBtn.style.background = "#8e44ad"; // Purple
                }
            }
            
            if (showingEstimate) {
                // If estimating, disable almost everything
                slider.disabled = true;
            } else {
                slider.disabled = false;
                slider.value = currentStep;
            }
            
            board.currentTurnColor = game.turn;
        }
        
        // --- AI Recommendation Logic ---
        function toggleRecommendation() {
            if (showingEstimate) { alert("请先关闭形势判断"); return; }
            
            const btn = document.getElementById('btn-ai-recommend');
            const originalText = btn.innerText;
            btn.innerText = "请求中...";
            
            // Construct moves list similar to estimate
            const limit = isTrialMode ? trialStartStep : currentStep;
            let moves = allMoves.slice(0, limit);
            if (isTrialMode && trialMoves.length > 0) {
                 const extraMoves = trialMoves.slice(0, currentTrialStep).map(m => {
                     return [m.c === WGo.B ? "B" : "W", toGTP(m.x, m.y)];
                 });
                 moves = moves.concat(extraMoves);
            }
            
            socket.emit('estimate_score', {moves: moves}, (response) => {
                btn.innerText = originalText;
                if (response && response.moveInfos) {
                    isRecommendationMode = true;
                    recommendationData = response.moveInfos;
                    render();
                } else {
                    alert("获取推荐失败");
                }
            });
        }
        
        function closeRecommendation() {
            // Reset ALL AI states to exit completely
            isEvolutionMode = false;
            currentEvolutionPV = [];
            isRecommendationMode = false;
            recommendationData = null;
            render();
        }

        // --- Estimation Logic ---
        function estimateScore() {
            if (showingEstimate) {
                closeEstimate();
                return;
            }
            
            const btn = document.getElementById('btn-estimate');
            const originalText = btn.innerText;
            btn.innerText = "计算中...";
            
            // Construct moves list based on current state (including trial moves)
            const limit = isTrialMode ? trialStartStep : currentStep;
            let moves = allMoves.slice(0, limit);
            
            if (isTrialMode && trialMoves.length > 0) {
                 // Must convert trialMoves [{x,y,c}] to ["B", "Q16"] format
                 const extraMoves = trialMoves.slice(0, currentTrialStep).map(m => {
                     return [m.c === WGo.B ? "B" : "W", toGTP(m.x, m.y)];
                 });
                 moves = moves.concat(extraMoves);
            }

            // If in Evolution Mode, append the evolution PV moves
            if (isEvolutionMode && currentEvolutionPV && currentEvolutionPV.length > 0) {
                 // Determine next color properly
                 let nextColor = (moves.length % 2 === 0) ? "B" : "W";
                 const evoMoves = currentEvolutionPV.map(coord => {
                      const move = [nextColor, coord];
                      nextColor = (nextColor === "B") ? "W" : "B";
                      return move;
                 });
                 moves = moves.concat(evoMoves);
            }
            
            socket.emit('estimate_score', {moves: moves}, (response) => {
                btn.innerText = originalText; // Restore button text
                if (response && response.ownership) {
                    showingEstimate = true;
                    estimateData = response;
                    
                    // Persistence
                    sessionStorage.setItem('estimationData', JSON.stringify(response));
                    sessionStorage.setItem('isEstimating', 'true');
                    sessionStorage.setItem('gameId', gameId);
                    
                    render();
                } else {
                    alert("形势判断失败");
                }
            });
        }
        
        function closeEstimate() {
            showingEstimate = false;
            estimateData = null;
            sessionStorage.removeItem('estimationData');
            sessionStorage.removeItem('isEstimating');
            render();
        }

        // --- Board Clicks ---
        board.addEventListener("click", (x, y) => {
            // Priority 1: If showing Estimate, block all
            if (showingEstimate) {
                 alert("请先关闭形势判断功能");
                 return;
            }
            
            // Priority 2: Evolution Mode -> Block all except Back (Button handled elsewhere)
            if (isEvolutionMode) {
                return;
            }

            // Priority 3: Recommendation Mode -> Check for recommend points
            if (isRecommendationMode) {
                const gtp = toGTP(x, y);
                // Check if click is on one of the top 3 recommendations
                const hit = recommendationData.slice(0, 3).find(info => info.move === gtp);
                if (hit) {
                    // Enter Evolution Mode
                    isEvolutionMode = true;
                    currentEvolutionPV = hit.pv;
                    render();
                }
                return; // Stop here, don't place stones
            }

            if (x < 0 || y < 0 || x >= 19 || y >= 19) return;
            const gtp = toGTP(x, y);

            // Normal Trial Logic
            if (!isTrialMode) {
                isTrialMode = true;
                trialStartStep = currentStep;
                trialMoves = [];
                currentTrialStep = 0;
                document.getElementById('btn-exit-trial').style.display = 'inline-block';
            }
            
            trialMoves = trialMoves.slice(0, currentTrialStep);
            trialMoves.push({x, y, c: board.currentTurnColor});
            currentTrialStep++;
            render();
        });

        // --- Standard Controls ---
        function jumpTo(step) {
             if (showingEstimate) { alert("请先关闭形势判断"); return; }
             if (isTrialMode) return;
             currentStep = parseInt(step);
             render();
        }
        
        function step(d) {
             if (showingEstimate) { alert("请先关闭形势判断"); return; }
             if (isTrialMode) {
                 const n = currentTrialStep + d;
                 if (n >= 0 && n <= trialMoves.length) {
                     currentTrialStep = n;
                     render();
                 }
             } else {
                 const n = currentStep + d;
                 if (n >= 0 && n <= allMoves.length) {
                     currentStep = n;
                     render();
                 }
             }
        }
        
        function exitTrial() {
            isTrialMode = false;
            trialMoves = [];
            document.getElementById('btn-exit-trial').style.display = 'none';
            render();
        }
        
        function back() { window.location.href = '/static/lobby.html'; }

        // --- Utils ---
        function fromGTP(vertex) {
            vertex = vertex.toUpperCase();
            let colChar = vertex[0];
            let rowStr = vertex.slice(1);
            if (colChar >= 'I') colChar = String.fromCharCode(colChar.charCodeAt(0) - 1);
            let x = colChar.charCodeAt(0) - 'A'.charCodeAt(0);
            let y = 19 - parseInt(rowStr);
            return {x, y};
        }
        function toGTP(x, y) {
            let colStr = "ABCDEFGHJKLMNOPQRST"[x];
            let rowStr = (19 - y).toString();
            return colStr + rowStr;
        }

        loadGame();
        
        function saveState() {
             const s = {currentStep, isTrialMode, trialMoves, trialStartStep, currentTrialStep};
             sessionStorage.setItem('replay_' + gameId, JSON.stringify(s));
        }
        function restoreState() {
            const s = sessionStorage.getItem('replay_' + gameId);
            if(s) {
                 const o = JSON.parse(s);
                 currentStep = o.currentStep; 
                 isTrialMode = o.isTrialMode;
                 trialMoves = o.trialMoves || [];
                 trialStartStep = o.trialStartStep || 0;
                 currentTrialStep = o.currentTrialStep || 0;
                 return true;
            }
            return false;
        }
    </script>
</body>
</html>
